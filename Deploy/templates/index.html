<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DentalGPT - Tr·ª£ √Ω nha khoa</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.0/full/pyodide.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <link rel="stylesheet" href="/static/style.css" />
  <link rel="icon" type="image/png" href="https://cdn.haitrieu.com/wp-content/uploads/2021/10/Logo-DH-Thuy-Loi.png">
  <style>
/* COLLAPSIBLE HEADER */
.collapsible {
  cursor: pointer;
  user-select: none;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: 600;
  color: #2563eb;
  background: #f9fafb;
  padding: 0.75rem 1rem;
  border: 1px solid #e2e8f0;
  border-radius: 0.5rem;
  margin-bottom: 0.75rem;
  transition: background 0.2s ease, color 0.2s;
}
.collapsible:hover {
  background: #eff6ff;
  color: #1d4ed8;
}
.collapsible > .arrow {
  transition: transform 0.3s ease;
  font-size: 0.9rem;
  color: #64748b;
}
.collapsible.open > .arrow {
  transform: rotate(90deg);
  color: #3b82f6;
}
.collapsible .section-badge {
  background: #3b82f6;
  color: white;
  padding: 0.2rem 0.5rem;
  border-radius: 0.25rem;
  font-size: 0.7rem;
  font-weight: 600;
}

/* CONTAINER & CONTENT BOX */
.content-container {
  margin-bottom: 1rem;
}
.content-box {
  padding: 1rem;
  background: white;
  border: 1px solid #e5e7eb;
  border-left: 4px solid #3b82f6;
  border-radius: 0.5rem;
  margin-bottom: 1rem;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.03);
  transition: all 0.3s ease;
  max-height: 0;
  overflow: hidden;
  opacity: 0;
}
.content-box.visible {
  max-height: 1000px;
  opacity: 1;
  overflow: visible;
}
.reasoning-box {
  border-left-color: #8b5cf6;
}
.expert-box {
  border-left-color: #10b981;
}

/* MARKDOWN STYLES */
.markdown-content {
  white-space: pre-wrap;
  word-wrap: break-word;
  line-height: 1.7;
  font-size: 1rem;
  color: #1f2937;
  padding: 1rem;
  background-color: #fdfdfd;
  border-radius: 0.5rem;
  box-shadow: inset 0 0 0 1px #e5e7eb;
  overflow-x: auto;
}
.markdown-content h1 {
  font-size: 1.5rem;
  margin: 1rem 0 0.5rem;
  font-weight: 700;
  border-bottom: 2px solid #e5e7eb;
  padding-bottom: 0.25rem;
}
.markdown-content h2 {
  font-size: 1.25rem;
  margin: 1rem 0 0.5rem;
  font-weight: 600;
  color: #1e3a8a;
  border-left: 4px solid #3b82f6;
  padding-left: 0.75rem;
}
.markdown-content h3 {
  font-size: 1.1rem;
  margin-top: 1rem;
  color: #374151;
  font-style: italic;
}
.markdown-content ul,
.markdown-content ol {
  margin: 0.75rem 0;
  padding-left: 1.5rem;
}
.markdown-content li {
  margin-bottom: 0.4rem;
}
.markdown-content p {
  margin: 0.75rem 0;
}
.markdown-content code {
  background: #f3f4f6;
  padding: 0.2rem 0.4rem;
  border-radius: 0.25rem;
  font-size: 0.9rem;
  color: #111827;
  font-family: 'Courier New', monospace;
}
.markdown-content strong {
  font-weight: 700;
  color: #111827;
}
.markdown-content em {
  font-style: italic;
  color: #6b7280;
}
.markdown-content blockquote {
  border-left: 4px solid #cbd5e1;
  padding-left: 1rem;
  margin: 1rem 0;
  font-style: italic;
  color: #6b7280;
}
.markdown-content table {
  width: 100%;
  border-collapse: collapse;
  margin: 1rem 0;
}
.markdown-content th,
.markdown-content td {
  border: 1px solid #e5e7eb;
  padding: 0.5rem;
}
.markdown-content thead {
  background-color: #f3f4f6;
  font-weight: 600;
}

/* INDICATORS */
.typing-indicator {
  display: inline-block;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: #3b82f6;
  animation: typing 1.4s infinite ease-in-out;
  margin: 0 2px;
}
.typing-indicator:nth-child(1) { animation-delay: -0.32s; }
.typing-indicator:nth-child(2) { animation-delay: -0.16s; }
@keyframes typing {
  0%, 80%, 100% { transform: scale(0); opacity: 0.5; }
  40% { transform: scale(1); opacity: 1; }
}
.stream-cursor {
  display: inline-block;
  width: 2px;
  height: 1.2em;
  background: #3b82f6;
  animation: blink 1s infinite;
  margin-left: 2px;
}
@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

/* PYTHON CODE UI */
.message-container {
  animation: slideIn 0.3s ease-out;
}
@keyframes slideIn {
  from { opacity: 0; transform: translateY(6px); }
  to { opacity: 1; transform: translateY(0); }
}
.answer-section {
  background: #fefefe;
  padding: 0.75rem;
  border-radius: 0.5rem;
  border: 1px solid #f3f4f6;
  margin-top: 0.3rem;
}
.python-code-block {
  position: relative;
  margin: 1rem 0;
  border: 1px solid #e5e7eb;
  border-radius: 0.5rem;
  overflow: hidden;
}
.python-code-header {
  background: #374151;
  color: white;
  padding: 0.5rem 1rem;
  font-size: 0.85rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.python-code-content {
  background: #1f2937;
  color: #f9fafb;
  padding: 1rem;
  font-family: 'Courier New', monospace;
  font-size: 0.9rem;
  overflow-x: auto;
}
.run-button {
  background: #10b981;
  color: white;
  border: none;
  padding: 0.25rem 0.75rem;
  border-radius: 0.25rem;
  cursor: pointer;
  font-size: 0.8rem;
  transition: background 0.2s;
}
.run-button:hover {
  background: #059669;
}
.run-button:disabled {
  background: #6b7280;
  cursor: not-allowed;
}
.python-output {
  background: #111827;
  color: #10b981;
  padding: 1rem;
  border-top: 1px solid #374151;
  font-family: 'Courier New', monospace;
  font-size: 0.85rem;
  white-space: pre-wrap;
  max-height: 200px;
  overflow-y: auto;
}
.loading-indicator {
  color: #fbbf24;
  display: none;
}
.plot-image {
  max-width: 100%;
  margin: 0.5rem 0;
  border: 1px solid #e5e7eb;
  border-radius: 0.25rem;
}
/* Agentic Canvas Styles */
.agentic-canvas {
  position: relative;
  user-select: text !important;
  -webkit-user-select: text !important;
  -moz-user-select: text !important;
  -ms-user-select: text !important;
}

.agentic-canvas * {
  user-select: text !important;
  -webkit-user-select: text !important;
  -moz-user-select: text !important;
  -ms-user-select: text !important;
}

.canvas-toolbar {
  position: absolute;
  top: 8px;
  right: 8px;
  display: flex;
  gap: 8px;
  z-index: 10;
}

.canvas-btn {
  padding: 4px 8px;
  font-size: 12px;
  border: 1px solid #cbd5e1;
  border-radius: 4px;
  background: white;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

.canvas-btn:hover {
  background: #f1f5f9;
  border-color: #94a3b8;
}

.canvas-btn:active {
  transform: translateY(1px);
}

.pdf-processing {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  z-index: 1000;
  display: none;
}

.pdf-spinner {
  border: 2px solid #f3f3f3;
  border-top: 2px solid #3498db;
  border-radius: 50%;
  width: 20px;
  height: 20px;
  animation: spin 1s linear infinite;
  display: inline-block;
  margin-right: 10px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
/* Editable Canvas Styles */
.canvas-content[contenteditable="true"] {
  border: 2px dashed #3b82f6;
  background: #fefefe;
  outline: none;
  min-height: 100px;
  padding: 16px;
  border-radius: 8px;
  transition: all 0.3s ease;
}

.canvas-content[contenteditable="true"]:focus {
  border-color: #1d4ed8;
  background: #ffffff;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.edit-mode-indicator {
  position: absolute;
  top: 40px;
  right: 8px;
  background: #f59e0b;
  color: white;
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 10px;
  font-weight: 600;
  z-index: 11;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.canvas-toolbar {
  position: absolute;
  top: 8px;
  right: 8px;
  display: flex;
  gap: 6px;
  z-index: 10;
}

.canvas-btn {
  padding: 4px 8px;
  font-size: 12px;
  border: 1px solid #cbd5e1;
  border-radius: 4px;
  background: white;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  display: flex;
  align-items: center;
  gap: 4px;
}

.canvas-btn:hover {
  background: #f1f5f9;
  border-color: #94a3b8;
  transform: translateY(-1px);
}

.canvas-btn.edit-active {
  background: #f59e0b;
  color: white;
  border-color: #d97706;
}

.canvas-btn.save-btn {
  background: #10b981;
  color: white;
  border-color: #059669;
}

.canvas-btn.save-btn:hover {
  background: #059669;
}

.canvas-btn.cancel-btn {
  background: #ef4444;
  color: white;
  border-color: #dc2626;
}

.canvas-btn.cancel-btn:hover {
  background: #dc2626;
}

/* Formatting toolbar */
.format-toolbar {
  position: sticky;
  top: 0;
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
  padding: 8px;
  margin-bottom: 12px;
  display: none;
  flex-wrap: wrap;
  gap: 4px;
  z-index: 12;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.format-toolbar.visible {
  display: flex;
}

.format-btn {
  padding: 4px 8px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  background: white;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.2s;
}

.format-btn:hover {
  background: #f3f4f6;
}

.format-btn.active {
  background: #3b82f6;
  color: white;
  border-color: #2563eb;
}

.auto-save-indicator {
  position: absolute;
  top: 70px;
  right: 8px;
  background: #10b981;
  color: white;
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 10px;
  z-index: 11;
  opacity: 0;
  transition: opacity 0.3s;
}

.auto-save-indicator.visible {
  opacity: 1;
}
.uploaded-files {
      max-height: 120px;
      overflow-y: auto;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 8px;
      margin-top: 8px;
      background: #f9fafb;
      display: none;
    }
    .uploaded-files.visible {
      display: block;
    }
    .file-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 8px;
      margin: 2px 0;
      background: white;
      border-radius: 6px;
      border: 1px solid #e5e7eb;
      font-size: 13px;
    }
    .file-info {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      min-width: 0;
    }
    .file-icon {
      font-size: 16px;
      flex-shrink: 0;
    }
    .file-name {
      font-weight: 500;
      color: #374151;
      overflow: hidden;
      white-space: nowrap;
      max-width: 200px;
    }
    .file-size {
      color: #6b7280;
      font-size: 11px;
      margin-left: 4px;
    }
    .remove-file {
      color: #ef4444;
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 4px;
      font-size: 12px;
      flex-shrink: 0;
    }
    .remove-file:hover {
      background: #fee2e2;
    }
    .file-upload-area {
      position: relative;
    }
    .upload-summary {
      font-size: 12px;
      color: #6b7280;
      margin-top: 4px;
    }
    /* Thay th·∫ø CSS cho input area */
    footer {
      position: relative; /* Th√™m position relative */
    }

    .input-wrapper {
      position: relative;
      flex: 1;
    }

    /* Icon upload file - d√≠nh v·ªõi input */
    .file-upload-icon {
      position: absolute;
      right: 100px; /* TƒÉng kho·∫£ng c√°ch ƒë·ªÉ ch·ª´a ch·ªó cho tools icon */
      top: 50%;
      transform: translateY(-50%);
      z-index: 10;
      background: white;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #e5e7eb;
      cursor: pointer;
      transition: all 0.2s;
    }

    .file-upload-icon:hover {
      background: #f3f4f6;
      border-color: #3b82f6;
      color: #3b82f6;
    }

    /* Icon tools - ngay b√™n c·∫°nh upload icon */
    .tools-icon {
      position: absolute;
      right: 60px; /* Ngay b√™n c·∫°nh upload icon */
      top: 50%;
      transform: translateY(-50%);
      z-index: 10;
      background: white;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #e5e7eb;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .tools-icon:hover {
      background: #f3f4f6;
      border-color: #3b82f6;
      color: #3b82f6;
    }

    .tools-icon:hover {
      background: #f3f4f6;
      border-color: #3b82f6;
      color: #3b82f6;
    }

    /* Dropdown tools - cƒÉn ch·ªânh l·∫°i theo icon tools */
    #tools-dropdown {
      position: absolute;
      top: -200px; /* Hi·ªÉn th·ªã ph√≠a tr√™n icon */
      right: 60px; /* Align v·ªõi tools icon */
      width: 200px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      border: 1px solid #e5e7eb;
      z-index: 20;
    }

    /* Uploaded files list - d√≠nh v·ªõi input */
    .uploaded-files {
      position: absolute;
      bottom: 100%;
      left: 0;
      right: 0;
      margin-bottom: 8px;
      z-index: 15;
    }
    .warning-message {
  position: absolute;
  bottom: 100%;
  left: 0;
  right: 0;
  background: #fef3c7;
  border: 1px solid #f59e0b;
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 8px;
  color: #92400e;
  font-size: 14px;
  display: none;
  z-index: 20;
  animation: slideDown 0.3s ease-out;
}

.warning-message.visible {
  display: block;
}

.warning-message .close-warning {
  float: right;
  cursor: pointer;
  font-weight: bold;
  color: #92400e;
  margin-left: 8px;
}

@keyframes slideDown {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}
</style>

</head>
<body class="h-screen w-screen overflow-hidden font-sans bg-gradient-to-br from-blue-50 to-indigo-100">

  <!-- Main layout -->
  <div class="flex h-full">

    <!-- Main Chat Panel -->
    <div class="flex-1 flex flex-col">
      <!-- Header -->
      <header class="p-6 bg-white shadow-lg rounded-b-2xl z-10 flex items-center justify-between border-b border-gray-200">
        <div class="flex items-center gap-4">
          <img src="https://cdn.haitrieu.com/wp-content/uploads/2021/10/Logo-DH-Thuy-Loi.png" alt="Logo" class="h-12 w-auto">
          <div>
            <h1 class="text-3xl font-extrabold text-blue-700 flex items-center gap-2">ü¶∑ DentalGPT</h1>
            <p class="text-base text-blue-500">Tr·ª£ l√Ω nha khoa th√¥ng minh</p>
          </div>
        </div>
        <div class="relative">
          <button id="settings-btn" class="p-2 text-gray-500 hover:text-blue-600 rounded-full">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
          </button>
          <div id="pdf-loading" class="pdf-processing">
            <div class="flex items-center">
              <div class="pdf-spinner"></div>
              <span>ƒêang t·∫°o PDF...</span>
            </div>
          </div>
          <div id="settings-panel" class="hidden absolute right-0 mt-2 w-64 bg-white rounded-lg shadow-xl z-20 p-4 border border-gray-200 transform transition-all duration-200 origin-top-right">
            <h3 class="font-medium text-gray-700 mb-3">C·∫•u h√¨nh tr·ª£ l√Ω ·∫£o</h3>
            <div class="space-y-3 text-sm">
              <div>
                <label class="block text-gray-600 mb-1">S·ªë t·ª´ t·ªëi ƒëa</label>
                <input id="max_tokens" type="number" min="1" max="4096" value="1024" class="w-full border rounded-lg p-2 focus:ring-2 focus:ring-blue-400">
              </div>
              <div>
                <label class="block text-gray-600 mb-1">M·ª©c ƒë·ªô s√°ng t·∫°o</label>
                <input id="temperature" type="number" step="0.1" min="0" max="2" value="0.1" class="w-full border rounded-lg p-2 focus:ring-2 focus:ring-blue-400">
              </div>
              <div>
                <label class="block text-gray-600 mb-1">ƒê·ªô ch·∫Øc ch·∫Øn</label>
                <input id="top_p" type="number" step="0.1" min="0" max="1" value="0.9" class="w-full border rounded-lg p-2 focus:ring-2 focus:ring-blue-400">
              </div>
            </div>
          </div>
        </div>
      </header>

      <!-- Chat content -->
      <main id="chat-box" class="flex-1 overflow-y-auto p-8 space-y-6 bg-white rounded-2xl m-4 shadow-lg transition-all duration-300">
        <div class="text-center text-gray-400">
          <div class="text-4xl mb-2 animate-bounce">üëã</div>
          <p class="text-lg">Xin ch√†o! T√¥i l√† <span class="font-bold text-blue-700">DentalGPT</span>. H√£y ƒë·∫∑t c√¢u h·ªèi v·ªÅ nha khoa...</p>
        </div>
        <!-- Tin nh·∫Øn s·∫Ω ƒë∆∞·ª£c render ·ªü ƒë√¢y, c√≥ th·ªÉ th√™m avatar cho bot/user -->
      </main>

      <!-- Input area -->
      <footer class="p-6 border-t border-gray-300 bg-white rounded-t-2xl shadow-lg">
        <!-- Input area -->
        <div class="flex items-center gap-3">
          <div class="input-wrapper">
            <div class="file-upload-area">
              <!-- Input ch√≠nh -->
              <input id="user-input" type="text" placeholder="Nh·∫≠p c√¢u h·ªèi..." class="w-full px-5 py-3 pr-32 border rounded-2xl shadow focus:outline-none focus:ring-2 focus:ring-blue-400 text-base" onkeydown="handleKeyPress(event)" />
              
              <!-- Icon upload file - d√≠nh v·ªõi input -->
              <div class="file-upload-icon" id="file-upload-btn" title="T·∫£i l√™n file PDF ho·∫∑c h√¨nh ·∫£nh">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                </svg>
                <input id="file-input" type="file" multiple accept=".pdf,.jpg,.jpeg,.png" class="hidden" />
              </div>
              
              <!-- Tools icon - ngay b√™n c·∫°nh upload icon -->
              <div class="tools-icon" id="tools-btn">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4" />
                </svg>
              </div>
              
              <!-- Tools dropdown -->
              <div id="tools-dropdown" class="hidden">
                <div class="py-1">
                  <button onclick="sendMessage('reason')" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">üß† Suy lu·∫≠n</button>
                  <button onclick="sendMessage('deep_reason')" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">üî¨ Suy lu·∫≠n s√¢u</button>
                  <button onclick="sendMessage('agentic')" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">üß¨ Agentic</button>
                  <button onclick="clearChat()" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">üóëÔ∏è X√≥a chat</button>
                  <button id="search-toggle-btn" onclick="toggleSearch()" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">üîé T√¨m ki·∫øm</button>
                </div>
              </div>
              
              <!-- Danh s√°ch file ƒë√£ upload -->
              <div id="uploaded-files" class="uploaded-files">
                <div class="upload-summary">
                  <span id="file-count">0 file ƒë√£ ch·ªçn</span>
                  <button id="clear-all-files" class="text-red-500 hover:text-red-700 text-xs ml-2 underline" style="display: none;">X√≥a t·∫•t c·∫£</button>
                </div>
                <div id="file-list"></div>
              </div>
              <div id="warning-message" class="warning-message">
                <span id="warning-text"></span>
                <span class="close-warning" onclick="hideWarning()">√ó</span>
              </div>
            </div>
          </div>
      
      <!-- N√∫t g·ª≠i -->
      <button onclick="sendMessage('normal')" id="send-btn" class="flex items-center gap-2 px-7 py-3 bg-blue-600 text-white rounded-2xl hover:bg-blue-700 transition text-lg font-semibold shadow">
        <span>G·ª≠i</span>
        <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M5 12h14M12 5l7 7-7 7"/></svg>
      </button>
    </div>
  </footer>


  <!-- Tools dropdown -->
  <div id="tools-dropdown" class="hidden">
    <div class="py-1">
      <button onclick="sendMessage('reason')" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">üß† Suy lu·∫≠n</button>
      <button onclick="sendMessage('deep_reason')" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">üî¨ Suy lu·∫≠n s√¢u</button>
      <button onclick="sendMessage('agentic')" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">üß¨ Agentic</button>
      <button onclick="clearChat()" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">üóëÔ∏è X√≥a chat</button>
      <button id="search-toggle-btn" onclick="toggleSearch()" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">üîé T√¨m ki·∫øm</button>
    </div>
  </div>
      <script>
        // Toggle tools dropdown
        document.getElementById('tools-btn').addEventListener('click', function(e) {
          e.stopPropagation();
          document.getElementById('tools-dropdown').classList.toggle('hidden');
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', function() {
          document.getElementById('tools-dropdown').classList.add('hidden');
        });
        // Th√™m bi·∫øn global ƒë·ªÉ l∆∞u tr·ªØ file
        let uploadedFiles = [];
        // File upload handling
        document.getElementById('file-upload-btn').addEventListener('click', function() {
        document.getElementById('file-input').click();
      });

      document.getElementById('file-input').addEventListener('change', function(e) {
      const files = Array.from(e.target.files);
      if (!files || files.length === 0) return;

      // Ki·ªÉm tra xung ƒë·ªôt v·ªõi search
      if (isSearchEnabled) {
        showWarning('‚ö†Ô∏è Vui l√≤ng t·∫Øt ch·ª©c nƒÉng t√¨m ki·∫øm tr∆∞·ªõc khi upload file.');
        e.target.value = ''; // Clear input
        return;
      }

      // Validate file types
      const allowedTypes = ['.pdf', '.jpg', '.jpeg', '.png'];
      const invalidFiles = files.filter(file => {
        const ext = '.' + file.name.split('.').pop().toLowerCase();
        return !allowedTypes.includes(ext);
      });

      if (invalidFiles.length > 0) {
        alert(`Ch·ªâ ch·∫•p nh·∫≠n file PDF v√† h√¨nh ·∫£nh (JPG, PNG). File kh√¥ng h·ª£p l·ªá: ${invalidFiles.map(f => f.name).join(', ')}`);
        return;
      }

      // Validate file size (max 50MB per file)
      const maxSize = 50 * 1024 * 1024; // 50MB
      const oversizedFiles = files.filter(file => file.size > maxSize);
      
      if (oversizedFiles.length > 0) {
        alert(`File qu√° l·ªõn (t·ªëi ƒëa 50MB). File v∆∞·ª£t qu√°: ${oversizedFiles.map(f => f.name).join(', ')}`);
        return;
      }

      // Add files to uploaded list
      files.forEach(file => {
        // Check if file already exists
        const exists = uploadedFiles.some(f => f.name === file.name && f.size === file.size);
        if (!exists) {
          uploadedFiles.push(file);
        }
      });

      // Update UI
      updateFileList();
      
      // Clear file input
      e.target.value = '';
    });

      // Function to update file list UI
      function updateFileList() {
      const fileListEl = document.getElementById('file-list');
      const uploadedFilesEl = document.getElementById('uploaded-files');
      const fileCountEl = document.getElementById('file-count');
      const clearAllBtn = document.getElementById('clear-all-files');

      if (uploadedFiles.length === 0) {
        uploadedFilesEl.classList.remove('visible');
        
        // Enable l·∫°i search khi kh√¥ng c√≥ file
        const searchBtn = document.getElementById('search-toggle-btn');
        searchBtn.style.opacity = '1';
        searchBtn.style.pointerEvents = 'auto';
        return;
      }

      // Disable search khi c√≥ file
      const searchBtn = document.getElementById('search-toggle-btn');
      searchBtn.style.opacity = '0.5';
      searchBtn.style.pointerEvents = 'none';

      uploadedFilesEl.classList.add('visible');
      fileCountEl.textContent = `${uploadedFiles.length} file ƒë√£ ch·ªçn`;
      clearAllBtn.style.display = uploadedFiles.length > 0 ? 'inline' : 'none';

      fileListEl.innerHTML = uploadedFiles.map((file, index) => {
        const icon = getFileIcon(file.name);
        const size = formatFileSize(file.size);
        
        return `
          <div class="file-item" data-index="${index}">
            <div class="file-info">
              <span class="file-icon">${icon}</span>
              <span class="file-name" title="${file.name}">${file.name}</span>
              <span class="file-size">${size}</span>
            </div>
            <button class="remove-file" onclick="removeFile(${index})" title="X√≥a file">√ó</button>
          </div>
        `;
      }).join('');
    }

      // Function to get file icon
      function getFileIcon(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        switch (ext) {
          case 'pdf': return 'üìÑ';
          case 'jpg':
          case 'jpeg':
          case 'png': return 'üñºÔ∏è';
          default: return 'üìé';
        }
      }

      // Function to format file size
      function formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
      }

      // Function to remove file
      function removeFile(index) {
        uploadedFiles.splice(index, 1);
        updateFileList();
      }

      // Function to clear all files
      document.getElementById('clear-all-files').addEventListener('click', function() {
        uploadedFiles = [];
        updateFileList();
      });

      </script>
    </div>

  </div>

  <!-- JS logic -->
  <script>const apiUrl = "http://localhost:8000/DentalGPT/chatbot/";
let isGenerating = false;
let currentBotMessage = null;
let streamBuffer = "";
let pyodide = null;
let isSearchEnabled = false;

function toggleSearch() {
  // Ki·ªÉm tra xung ƒë·ªôt tr∆∞·ªõc khi b·∫≠t search
  if (!isSearchEnabled && uploadedFiles.length > 0) {
    showWarning('‚ö†Ô∏è Vui l√≤ng x√≥a t·∫•t c·∫£ file tr∆∞·ªõc khi b·∫≠t ch·ª©c nƒÉng t√¨m ki·∫øm.');
    return;
  }
  
  isSearchEnabled = !isSearchEnabled;
  const btn = document.getElementById('search-toggle-btn');
  
  if (isSearchEnabled) {
    btn.innerHTML = '‚úÖ Search ON';
    btn.classList.add('bg-green-600', 'hover:bg-green-700');
    btn.classList.remove('bg-transparent', 'hover:bg-gray-100');
    
    // Disable file upload khi search b·∫≠t
    const fileUploadIcon = document.getElementById('file-upload-btn');
    fileUploadIcon.style.opacity = '0.5';
    fileUploadIcon.style.pointerEvents = 'none';
    fileUploadIcon.title = 'T·∫Øt t√¨m ki·∫øm ƒë·ªÉ s·ª≠ d·ª•ng upload file';
  } else {
    btn.innerHTML = 'üîé T√¨m ki·∫øm';
    btn.classList.remove('bg-green-600', 'hover:bg-green-700');
    btn.classList.add('bg-transparent', 'hover:bg-gray-100');
    
    // Enable l·∫°i file upload
    const fileUploadIcon = document.getElementById('file-upload-btn');
    fileUploadIcon.style.opacity = '1';
    fileUploadIcon.style.pointerEvents = 'auto';
    fileUploadIcon.title = 'T·∫£i l√™n file PDF ho·∫∑c h√¨nh ·∫£nh';
  }
}
// Initialize Pyodide with matplotlib support
async function initPyodide() {
  if (!pyodide) {
    try {
      pyodide = await loadPyodide();
      // Load required packages
      await pyodide.loadPackage("micropip");
      await pyodide.runPythonAsync(`
        import micropip
        await micropip.install([
          'matplotlib',
          'numpy',
          'pandas',
          'seaborn'
        ])
      `);
      console.log("Pyodide initialized successfully with matplotlib");
    } catch (error) {
      console.error("Failed to initialize Pyodide:", error);
    }
  }
  return pyodide;
}

// Auto-execute Python code and return result HTML
async function autoExecutePythonCode(code) {
  if (!pyodide) {
    await initPyodide();
  }

  if (!pyodide) {
    return `<div class="python-error">L·ªói: Kh√¥ng th·ªÉ kh·ªüi t·∫°o Python runner</div>`;
  }

  // try {
  // Set up matplotlib backend and capture system
  await pyodide.runPythonAsync(`
    import matplotlib
    matplotlib.use('AGG')  # Use non-interactive backend
    import matplotlib.pyplot as plt
    import io
    import base64
    import sys
    from io import StringIO
    
    import numpy as np
    import pandas as pd
    import seaborn as sns

    # Capture stdout for text output
    sys.stdout = StringIO()
    
    # Clear any existing plots
    plt.clf()
  `);

  // Run the user code
  await pyodide.runPythonAsync(code);

  // Get text output
  const textOutput = await pyodide.runPythonAsync("sys.stdout.getvalue()");

  // Try to get plot output
  let imageOutput = null;
  try {
    const hasPlot = await pyodide.runPythonAsync(`
      import matplotlib.pyplot as plt
      len(plt.get_fignums()) > 0
    `);

    if (hasPlot) {
      imageOutput = await pyodide.runPythonAsync(`
        import matplotlib.pyplot as plt
        import io
        import base64

        buf = io.BytesIO()
        plt.savefig(buf, format='png', dpi=150, bbox_inches='tight')
        buf.seek(0)
        encoded = base64.b64encode(buf.read()).decode('utf-8')
        plt.close()
        encoded
      `);
    }
  } catch (plotError) {
    console.log("No plot to save:", plotError);
  }

  // Build result HTML
  let resultHtml = '';

  if (imageOutput) {
    resultHtml = `
      <div class="python-result">
        <div class="python-result-content">
          <div class="python-plot-output">
            <img src="data:image/png;base64,${imageOutput}" alt="Generated Plot" />
          </div>
        </div>
      </div>
    `;
  } else if (textOutput && textOutput.trim()) {
    resultHtml = `
      <div class="python-result">
        <div class="python-result-header">
          <span>üêç</span>
          <span>K·∫øt qu·∫£ Python</span>
        </div>
        <div class="python-result-content">
          <div class="python-text-output">${textOutput}</div>
        </div>
      </div>
    `;
  } else {
    resultHtml = `
      <div class="python-result">
        <div class="python-result-header">
          <span>‚úÖ</span>
          <span>Python ƒë√£ ch·∫°y th√†nh c√¥ng</span>
        </div>
        <div class="python-result-content">
          <div class="text-green-600 text-sm">Ch∆∞∆°ng tr√¨nh ƒë√£ ch·∫°y th√†nh c√¥ng (kh√¥ng c√≥ output)</div>
        </div>
      </div>
    `;
  }

  return resultHtml;

  // } catch (error) {
  //   return `
  //     <div class="python-result">
  //       <div class="python-result-header">
  //         <span>‚ùå</span>
  //         <span>L·ªói Python</span>
  //       </div>
  //       <div class="python-result-content">
  //         <div class="python-error">L·ªói: ${error.message}</div>
  //       </div>
  //     </div>
  //   `;
  // }
}

// Chat Template Class to manage rendering
class ChatTemplate {
  constructor() {
    this.sections = {
      reasoning_cot: { 
        title: "üß† Qu√° tr√¨nh suy lu·∫≠n", 
        content: "", 
        visible: false,
        badge: "SUY LU·∫¨N",
        icon: "ü§î"
      },
      experting: { 
        title: "üë®‚Äçüî¨ Ph√¢n t√≠ch chuy√™n gia", 
        content: "", 
        visible: false,
        badge: "CHUY√äN GIA",
        icon: "üî¨"
      },
      answer: { 
        title: "", 
        content: "", 
        visible: true 
      }
    };
  }

  reset() {
    Object.keys(this.sections).forEach(key => {
      this.sections[key].content = "";
      this.sections[key].visible = key === 'answer';
    });
  }

  updateSection(sectionName, content) {
    if (this.sections[sectionName]) {
      this.sections[sectionName].content = content;
    }
  }

  async render() {
    let html = "";
    
    // Render collapsible sections with separate boxes
    for (const [key, section] of Object.entries(this.sections)) {
      if (key !== 'answer' && section.content.trim()) {
        html += await this.renderCollapsibleSection(key, section);
      }
    }

    // Render answer section
    if (this.sections.answer.content.trim()) {
      html += await this.renderAnswerSection(this.sections.answer.content);
    }

    return html;
  }

  async renderCollapsibleSection(key, section) {
    const extraClass = key === 'reasoning_cot' ? 'reasoning-box' : 'expert-box';
    const hasContent = section.content.trim() !== '';
    
    return `
      <div class="content-container">
        <div class="collapsible" data-section="${key}">
          <span class="arrow">‚ñ∂</span>
          <span class="section-badge">${section.badge}</span>
          <span>${section.title}</span>
          ${hasContent ? '<span class="text-xs text-blue-500 ml-auto">Click ƒë·ªÉ xem chi ti·∫øt</span>' : ''}
        </div>
        <div class="content-box ${extraClass}" data-content="${key}">
          <div class="markdown-content">${await this.markdownToHtml(section.content)}</div>
        </div>
      </div>
    `;
  }

  async renderAnswerSection(content) {
    return `
      <div class="answer-section">
        <div class="markdown-content prose max-w-none">
          ${await this.markdownToHtml(content)}
        </div>
      </div>
    `;
  }

  async markdownToHtml(text) {
    try {
      let html = marked.parse(text);
      // Process Python code blocks - auto-run and replace with results
      html = await this.processPythonCodeBlocks(html);
      return html;
    } catch (e) {
      return text.replace(/\n/g, '<br>');
    }
  }

  async processPythonCodeBlocks(html) {
    // Regex to find Python code blocks
    const pythonCodeRegex = /<pre><code class="language-python">([\s\S]*?)<\/code><\/pre>/g;
    // Process all matches
    const matches = [...html.matchAll(pythonCodeRegex)];
    for (const match of matches) {
      const fullMatch = match[0];
      const code = match[1].trim();
      const decodedCode = this.decodeHtml(code);

      // Show loading state first
      const loadingHtml = `
        <div class="python-execution-container">
          <div class="python-loading">
            <div class="spinner"></div>
            <span>ƒêang ch·∫°y code Python...</span>
          </div>
        </div>
      `;

      // Replace with loading first
      html = html.replace(fullMatch, loadingHtml);

      // Execute the code and get result
      let resultHtml = "";
      try {
        const resultHtml = await autoExecutePythonCode(decodedCode);
        // Replace loading with result
        html = html.replace(loadingHtml, resultHtml);
      } catch (error) {
        // resultHtml = `
        //   <div class="python-result">
        //     <div class="python-result-header">
        //       <span>‚ùå</span>
        //       <span>L·ªói Python</span>
        //     </div>
        //     <div class="python-result-content">
        //       <div class="python-error">L·ªói: ${error.message || "Kh√¥ng c√≥ bi·ªÉu ƒë·ªì ho·∫∑c output."}</div>
        //     </div>
        //   </div>
        // `;
        resultHtml = `
          <div class="python-result">
            <div class="python-result-header">
              <span class="animate-pulse">üñåÔ∏è</span>
              <span>ƒêang v·∫Ω bi·ªÉu ƒë·ªì...</span>
            </div>
            <div class="python-result-content">
              <div class="python-error text-yellow-600">
                ‚è≥ ƒêang x·ª≠ l√Ω: ${error.message || "Kh√¥ng c√≥ bi·ªÉu ƒë·ªì ho·∫∑c output."}
              </div>
            </div>
          </div>
        `;
      }
      // Lu√¥n thay th·∫ø loadingHtml b·∫±ng resultHtml (d√π th√†nh c√¥ng hay l·ªói)
      html = html.replace(loadingHtml, resultHtml);
    }
    return html;
  }

  decodeHtml(html) {
    const txt = document.createElement("textarea");
    txt.innerHTML = html;
    return txt.value;
  }

  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
}

const template = new ChatTemplate();

function handleKeyPress(event) {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    if (!isGenerating) {
      sendMessage('normal');
    }
  }
}

function clearChat() {
  document.getElementById("chat-box").innerHTML = `
    <div class="text-gray-500 text-sm text-center py-8">
      <div class="text-2xl mb-2">üëã</div>
      Xin ch√†o! T√¥i l√† DentalGPT. H√£y ƒë·∫∑t c√¢u h·ªèi v·ªÅ nha khoa...
    </div>
  `;
  // Reset section states
  sectionStates = {};
}

function appendMessage(text, isUser) {
  const chatBox = document.getElementById("chat-box");
  
  // Clear welcome message if exists
  if (chatBox.children.length === 1 && chatBox.children[0].classList.contains('text-center')) {
    chatBox.innerHTML = '';
  }

  const msg = document.createElement("div");
  msg.className = `message-container flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`;
  
  if (isUser) {
    msg.innerHTML = `
      <div class="bg-blue-600 text-white p-4 rounded-2xl max-w-[75%] shadow-lg">
        <div class="whitespace-pre-wrap">${escapeHtml(text)}</div>
      </div>
    `;
  } else {
    const botContent = document.createElement("div");
    botContent.className = "bg-gray-50 border border-gray-200 text-gray-900 p-4 rounded-2xl max-w-[90%] shadow-lg";
    
    if (text === "") {
      // Show typing indicator
      botContent.innerHTML = `
        <div class="flex items-center gap-2">
          <span class="typing-indicator"></span>
          <span class="typing-indicator"></span>
          <span class="typing-indicator"></span>
          <span class="text-sm text-gray-500 ml-2">ƒêang suy nghƒ©...</span>
        </div>
      `;
    } else {
      botContent.innerHTML = text;
    }
    
    msg.appendChild(botContent);
    currentBotMessage = botContent;
  }
  
  chatBox.appendChild(msg);
  chatBox.scrollTop = chatBox.scrollHeight;
  
  return isUser ? null : currentBotMessage;
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function extractSection(text, sectionName) {
  // Try to find complete section first
  const completeRegex = new RegExp(`<${sectionName}>([\\s\\S]*?)<\\/${sectionName}>`, 'g');
  const completeMatch = text.match(completeRegex);
  
  if (completeMatch) {
    return completeMatch[0].replace(new RegExp(`<\\/?${sectionName}>`, 'g'), '').trim();
  }
  
  // If no complete section, try to find incomplete/streaming section
  const incompleteRegex = new RegExp(`<${sectionName}>(([\\s\\S]*?)(?=<\\/|$))`, 'g');
  const incompleteMatch = text.match(incompleteRegex);
  
  if (incompleteMatch) {
    return incompleteMatch[0].replace(new RegExp(`<${sectionName}>`, 'g'), '').trim();
  }
  
  return "";
}

// Global state to track section visibility
let sectionStates = {};

function bindCollapsibleEvents() {
  // Use event delegation on the chat box to handle dynamic content
  const chatBox = document.getElementById("chat-box");
  
  // Remove existing listener if any
  chatBox.removeEventListener('click', handleCollapsibleClick);
  
  // Add event listener with delegation
  chatBox.addEventListener('click', handleCollapsibleClick);
}

function handleCollapsibleClick(e) {
  // Check if clicked element is a collapsible or its child
  const collapsible = e.target.closest('.collapsible');
  if (!collapsible) return;
  
  e.preventDefault();
  e.stopPropagation();
  
  const sectionKey = collapsible.dataset.section;
  const contentBox = collapsible.parentElement.querySelector('.content-box[data-content="' + sectionKey + '"]');
  const arrow = collapsible.querySelector('.arrow');
  
  if (contentBox && arrow) {
    // Toggle state
    const currentState = sectionStates[sectionKey] || false;
    const newState = !currentState;
    sectionStates[sectionKey] = newState;
    
    // Apply state
    if (newState) {
      contentBox.classList.add('visible');
      arrow.textContent = '‚ñº';
      collapsible.classList.add('open');
    } else {
      contentBox.classList.remove('visible');
      arrow.textContent = '‚ñ∂';
      collapsible.classList.remove('open');
    }
  }
}

function applySectionStates() {
  // Apply saved states to all sections
  Object.keys(sectionStates).forEach(sectionKey => {
    const isOpen = sectionStates[sectionKey];
    const collapsible = currentBotMessage ? currentBotMessage.querySelector(`.collapsible[data-section="${sectionKey}"]`) : null;
    const contentBox = currentBotMessage ? currentBotMessage.querySelector(`.content-box[data-content="${sectionKey}"]`) : null;
    
    if (collapsible && contentBox) {
      const arrow = collapsible.querySelector('.arrow');
      if (isOpen) {
        contentBox.classList.add('visible');
        arrow.textContent = '‚ñº';
        collapsible.classList.add('open');
      } else {
        contentBox.classList.remove('visible');
        arrow.textContent = '‚ñ∂';
        collapsible.classList.remove('open');
      }
    }
  });
}

async function parseStreamingResponse(rawText) {
  // Remove control tags
  let text = rawText.replace(/<ÔΩú[^ÔΩú]*ÔΩú>/g, "");
  
  // Extract sections using regex - improved for incomplete tags
  const sections = {
    reasoning_cot: extractSection(text, 'reasoning_cot'),
    experting: extractSection(text, 'experting'),
    answer: extractSection(text, 'answer')
  };

  // Update template
  template.reset();
  Object.entries(sections).forEach(([key, content]) => {
    if (content) {
      template.updateSection(key, content);
    }
  });

  return await template.render();
}

async function sendMessage(mode = "normal") {
  if (isGenerating) return;

  const input = document.getElementById("user-input");
  const prompt = input.value.trim();
  if (!prompt) return;
  if (checkConflict()) {
      return;
    }
  // N·∫øu c√≥ file, upload tr∆∞·ªõc khi g·ª≠i
  let filePaths = [];
  if (uploadedFiles.length > 0) {
    try {
      const formData = new FormData();
      uploadedFiles.forEach(file => {
        formData.append('files', file);
      });

      const uploadResponse = await fetch('http://localhost:8000/DentalGPT/upload_files/', {
        method: 'POST',
        body: formData
      });

      if (!uploadResponse.ok) {
        const errorData = await uploadResponse.json();
        throw new Error(errorData.detail || 'Upload failed');
      }

      const result = await uploadResponse.json();
      filePaths = result.file_paths;
      
      // Clear uploaded files after successful upload
      uploadedFiles = [];
      updateFileList();
      
    } catch (error) {
      alert(`L·ªói upload file: ${error.message}`);
      return;
    }
  }

  isGenerating = true;
  const sendBtn = document.getElementById("send-btn");
  sendBtn.textContent = "ƒêang x·ª≠ l√Ω...";
  sendBtn.disabled = true;

  appendMessage(prompt, true);
  input.value = "";
  currentBotMessage = appendMessage("", false);

  const params = {
    prompt: prompt,
    file_paths: filePaths,
    max_new_tokens: parseInt(document.getElementById("max_tokens").value),
    temperature: parseFloat(document.getElementById("temperature").value),
    top_p: parseFloat(document.getElementById("top_p").value),
    top_k: 50,
    repetition_penalty: 1.0,
    do_sample: true,
    mode: mode,
    module: isSearchEnabled ? "search_all" : null
  };

  try {
    const response = await fetch(apiUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(params)
    });

    if (!response.ok) {
      throw new Error(`Server error: ${response.statusText}`);
    }

    if (mode === "agentic") {
      // Clear typing indicator
      currentBotMessage.innerHTML = "";

      const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let agenticText = "";

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      agenticText += decoder.decode(value, { stream: true });
    }

    const canvasId = `agentic-canvas-${Date.now()}`;
    const canvasHtml = `
      <div class="answer-section border-2 border-blue-600 bg-blue-50 p-4 rounded-xl shadow-lg agentic-canvas" id="${canvasId}">
        <div class="canvas-toolbar">
          <button class="canvas-btn edit-btn" onclick="toggleEditMode(this)" title="Ch·ªânh s·ª≠a">
            ‚úèÔ∏è Ch·ªânh s·ª≠a
          </button>
          <button class="canvas-btn save-btn" onclick="saveCanvas(this)" title="L∆∞u" style="display: none;">
            üíæ L∆∞u
          </button>
          <button class="canvas-btn cancel-btn" onclick="cancelEdit(this)" title="H·ªßy" style="display: none;">
            ‚ùå H·ªßy
          </button>
          <button class="canvas-btn" onclick="selectAllCanvas(this)" title="Ch·ªçn t·∫•t c·∫£">
            üìã Ch·ªçn t·∫•t c·∫£
          </button>
          <button class="canvas-btn" onclick="exportCanvasToPDF(this)" title="Xu·∫•t PDF">
            üìÑ Xu·∫•t PDF
          </button>
        </div>
        <div class="edit-mode-indicator" style="display: none;">
          ƒêANG CH·ªàNH S·ª¨A
        </div>
        <div class="auto-save-indicator">
          ƒê√£ l∆∞u t·ª± ƒë·ªông
        </div>
        <div class="format-toolbar">
          <button class="format-btn" onclick="formatText('bold')" title="ƒê·∫≠m">
            <b>B</b>
          </button>
          <button class="format-btn" onclick="formatText('italic')" title="Nghi√™ng">
            <i>I</i>
          </button>
          <button class="format-btn" onclick="formatText('underline')" title="G·∫°ch ch√¢n">
            <u>U</u>
          </button>
          <span style="border-left: 1px solid #d1d5db; margin: 0 4px;"></span>
          <button class="format-btn" onclick="formatText('insertOrderedList')" title="Danh s√°ch s·ªë">
            1. 2. 3.
          </button>
          <button class="format-btn" onclick="formatText('insertUnorderedList')" title="Danh s√°ch">
            ‚Ä¢ ‚Ä¢ ‚Ä¢
          </button>
          <span style="border-left: 1px solid #d1d5db; margin: 0 4px;"></span>
          <button class="format-btn" onclick="formatText('justifyLeft')" title="CƒÉn tr√°i">
            ‚¨ÖÔ∏è
          </button>
          <button class="format-btn" onclick="formatText('justifyCenter')" title="CƒÉn gi·ªØa">
            ‚ÜîÔ∏è
          </button>
          <button class="format-btn" onclick="formatText('justifyRight')" title="CƒÉn ph·∫£i">
            ‚û°Ô∏è
          </button>
        </div>
        <div class="flex items-center gap-2 mb-3">
          <span class="text-lg">üî∑</span>
          <span class="font-bold text-blue-800">Agentic Canvas</span>
        </div>
        <div class="markdown-content prose max-w-none canvas-content" data-original-content="">
          ${await template.markdownToHtml(agenticText)}
        </div>
      </div>
    `;
      // Render canvas HTML

    currentBotMessage.innerHTML = canvasHtml;
      
    } else {
      // Handle streaming response for normal mode
      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");
      streamBuffer = "";
      
      // Reset section states for new conversation
      sectionStates = {};

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value, { stream: true });
        streamBuffer += chunk;
        
        // Parse and render the accumulated content
        const parsedContent = await parseStreamingResponse(streamBuffer);
        currentBotMessage.innerHTML = parsedContent + '<span class="stream-cursor"></span>';
        
        // Apply saved section states after content update
        applySectionStates();

        // Auto scroll
        const chatBox = document.getElementById("chat-box");
        chatBox.scrollTop = chatBox.scrollHeight;
        
        // Small delay for smooth streaming effect
        await new Promise(resolve => setTimeout(resolve, 30));
      }

      // Remove cursor and finalize
      if (currentBotMessage) {
        const finalContent = await parseStreamingResponse(streamBuffer);
        currentBotMessage.innerHTML = finalContent;
        applySectionStates();
      }
    }

  } catch (error) {
    if (currentBotMessage) {
      currentBotMessage.innerHTML = `
        <div class="text-red-600 flex items-center gap-2">
          <span>‚ö†Ô∏è</span>
          <span>ƒê√£ x·∫£y ra l·ªói khi k·∫øt n·ªëi ƒë·∫øn m√°y ch·ªß: ${error.message}</span>
        </div>
      `;
    }
    console.error("Error:", error);
  } finally {
    isGenerating = false;
    sendBtn.textContent = "G·ª≠i";
    sendBtn.disabled = false;
  }
}
function selectAllCanvas(button) {
  const canvas = button.closest('.agentic-canvas');
  const content = canvas.querySelector('.canvas-content');
  
  if (window.getSelection) {
    const selection = window.getSelection();
    const range = document.createRange();
    range.selectNodeContents(content);
    selection.removeAllRanges();
    selection.addRange(range);
  } else if (document.selection) {
    const range = document.body.createTextRange();
    range.moveToElementText(content);
    range.select();
  }
}

async function exportCanvasToPDF(button) {
  const canvas = button.closest('.agentic-canvas');
  const loading = document.getElementById('pdf-loading');
  
  try {
    // Hi·ªÉn th·ªã loading
    loading.style.display = 'block';
    
    // T·∫°o clone ƒë·ªÉ x·ª≠ l√Ω
    const clone = canvas.cloneNode(true);
    clone.style.position = 'absolute';
    clone.style.left = '-9999px';
    clone.style.top = '0';
    clone.style.width = '800px';
    clone.style.background = 'white';
    clone.style.padding = '20px';
    
    // ·∫®n toolbar trong clone
    const toolbar = clone.querySelector('.canvas-toolbar');
    if (toolbar) toolbar.style.display = 'none';
    
    document.body.appendChild(clone);
    
    // T·∫°o canvas t·ª´ HTML
    const canvas2d = await html2canvas(clone, {
      scale: 2,
      useCORS: true,
      backgroundColor: '#ffffff',
      width: 840,
      height: clone.offsetHeight + 40
    });
    
    // T·∫°o PDF
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF('p', 'mm', 'a4');
    
    const imgData = canvas2d.toDataURL('image/png');
    const imgWidth = 210; // A4 width in mm
    const pageHeight = 297; // A4 height in mm
    const imgHeight = (canvas2d.height * imgWidth) / canvas2d.width;
    let heightLeft = imgHeight;
    
    let position = 0;
    
    // Th√™m trang ƒë·∫ßu ti√™n
    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
    heightLeft -= pageHeight;
    
    // Th√™m c√°c trang ti·∫øp theo n·∫øu c·∫ßn
    while (heightLeft >= 0) {
      position = heightLeft - imgHeight;
      pdf.addPage();
      pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
      heightLeft -= pageHeight;
    }
    
    // L∆∞u PDF
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    pdf.save(`DentalGPT_Agentic_Canvas_${timestamp}.pdf`);
    
    // Cleanup
    document.body.removeChild(clone);
    
  } catch (error) {
    console.error('L·ªói t·∫°o PDF:', error);
    alert('C√≥ l·ªói x·∫£y ra khi t·∫°o PDF. Vui l√≤ng th·ª≠ l·∫°i.');
  } finally {
    loading.style.display = 'none';
  }
}
// Initialize
document.addEventListener('DOMContentLoaded', function() {
  document.getElementById('user-input').focus();
  // Initialize event delegation for collapsibles
  bindCollapsibleEvents();
  // Initialize Pyodide in background
  initPyodide();
  
  // Toggle settings panel with animation
  const settingsBtn = document.getElementById('settings-btn');
  const settingsPanel = document.getElementById('settings-panel');
  
  settingsBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    settingsPanel.classList.toggle('hidden');
    if (!settingsPanel.classList.contains('hidden')) {
      settingsPanel.classList.remove('opacity-0', 'scale-95');
      settingsPanel.classList.add('opacity-100', 'scale-100');
    } else {
      settingsPanel.classList.remove('opacity-100', 'scale-100');
      settingsPanel.classList.add('opacity-0', 'scale-95');
    }
  });
  
  // Close settings when clicking outside
  document.addEventListener('click', (e) => {
    if (!settingsPanel.contains(e.target) && e.target !== settingsBtn) {
      settingsPanel.classList.add('hidden');
      settingsPanel.classList.remove('opacity-100', 'scale-100');
      settingsPanel.classList.add('opacity-0', 'scale-95');
    }
  });
});
// 3. Th√™m c√°c function m·ªõi cho ch·ªânh s·ª≠a
let editingSessions = new Map();

function toggleEditMode(button) {
  const canvas = button.closest('.agentic-canvas');
  const content = canvas.querySelector('.canvas-content');
  const editIndicator = canvas.querySelector('.edit-mode-indicator');
  const formatToolbar = canvas.querySelector('.format-toolbar');
  const saveBtn = canvas.querySelector('.save-btn');
  const cancelBtn = canvas.querySelector('.cancel-btn');
  
  if (content.contentEditable === 'true') {
    // T·∫Øt ch·∫ø ƒë·ªô ch·ªânh s·ª≠a
    exitEditMode(canvas);
  } else {
    // B·∫≠t ch·∫ø ƒë·ªô ch·ªânh s·ª≠a
    enterEditMode(canvas);
  }
}

function enterEditMode(canvas) {
  const content = canvas.querySelector('.canvas-content');
  const editBtn = canvas.querySelector('.edit-btn');
  const editIndicator = canvas.querySelector('.edit-mode-indicator');
  const formatToolbar = canvas.querySelector('.format-toolbar');
  const saveBtn = canvas.querySelector('.save-btn');
  const cancelBtn = canvas.querySelector('.cancel-btn');
  
  // L∆∞u n·ªôi dung g·ªëc
  content.dataset.originalContent = content.innerHTML;
  
  // B·∫≠t contentEditable
  content.contentEditable = 'true';
  content.focus();
  
  // C·∫≠p nh·∫≠t UI
  editBtn.classList.add('edit-active');
  editBtn.innerHTML = '‚úèÔ∏è ƒêang s·ª≠a';
  editIndicator.style.display = 'block';
  formatToolbar.classList.add('visible');
  saveBtn.style.display = 'inline-flex';
  cancelBtn.style.display = 'inline-flex';
  
  // Th√™m event listeners
  content.addEventListener('input', handleAutoSave);
  content.addEventListener('keydown', handleKeydown);
  
  // L∆∞u session
  editingSessions.set(canvas.id, {
    originalContent: content.innerHTML,
    autoSaveTimer: null
  });
}

function exitEditMode(canvas) {
  const content = canvas.querySelector('.canvas-content');
  const editBtn = canvas.querySelector('.edit-btn');
  const editIndicator = canvas.querySelector('.edit-mode-indicator');
  const formatToolbar = canvas.querySelector('.format-toolbar');
  const saveBtn = canvas.querySelector('.save-btn');
  const cancelBtn = canvas.querySelector('.cancel-btn');
  
  // T·∫Øt contentEditable
  content.contentEditable = 'false';
  
  // C·∫≠p nh·∫≠t UI
  editBtn.classList.remove('edit-active');
  editBtn.innerHTML = '‚úèÔ∏è Ch·ªânh s·ª≠a';
  editIndicator.style.display = 'none';
  formatToolbar.classList.remove('visible');
  saveBtn.style.display = 'none';
  cancelBtn.style.display = 'none';
  
  // X√≥a event listeners
  content.removeEventListener('input', handleAutoSave);
  content.removeEventListener('keydown', handleKeydown);
  
  // X√≥a session
  const session = editingSessions.get(canvas.id);
  if (session && session.autoSaveTimer) {
    clearTimeout(session.autoSaveTimer);
  }
  editingSessions.delete(canvas.id);
}

function saveCanvas(button) {
  const canvas = button.closest('.agentic-canvas');
  const content = canvas.querySelector('.canvas-content');
  const autoSaveIndicator = canvas.querySelector('.auto-save-indicator');
  
  // X√≥a n·ªôi dung g·ªëc ƒë√£ l∆∞u
  content.dataset.originalContent = content.innerHTML;
  
  // Hi·ªÉn th·ªã th√¥ng b√°o ƒë√£ l∆∞u
  autoSaveIndicator.classList.add('visible');
  setTimeout(() => {
    autoSaveIndicator.classList.remove('visible');
  }, 2000);
  
  // Tho√°t ch·∫ø ƒë·ªô ch·ªânh s·ª≠a
  exitEditMode(canvas);
  
  console.log('Canvas ƒë√£ ƒë∆∞·ª£c l∆∞u:', content.innerHTML);
}

function cancelEdit(button) {
  const canvas = button.closest('.agentic-canvas');
  const content = canvas.querySelector('.canvas-content');
  
  // Kh√¥i ph·ª•c n·ªôi dung g·ªëc
  content.innerHTML = content.dataset.originalContent;
  
  // Tho√°t ch·∫ø ƒë·ªô ch·ªânh s·ª≠a
  exitEditMode(canvas);
}

function handleAutoSave(event) {
  const canvas = event.target.closest('.agentic-canvas');
  const session = editingSessions.get(canvas.id);
  
  if (session) {
    // H·ªßy timer c≈©
    if (session.autoSaveTimer) {
      clearTimeout(session.autoSaveTimer);
    }
    
    // T·∫°o timer m·ªõi ƒë·ªÉ auto-save sau 2 gi√¢y
    session.autoSaveTimer = setTimeout(() => {
      const autoSaveIndicator = canvas.querySelector('.auto-save-indicator');
      autoSaveIndicator.classList.add('visible');
      setTimeout(() => {
        autoSaveIndicator.classList.remove('visible');
      }, 1500);
    }, 2000);
  }
}

function handleKeydown(event) {
  // Ctrl+S ƒë·ªÉ l∆∞u
  if (event.ctrlKey && event.key === 's') {
    event.preventDefault();
    const canvas = event.target.closest('.agentic-canvas');
    const saveBtn = canvas.querySelector('.save-btn');
    saveCanvas(saveBtn);
  }
  
  // Esc ƒë·ªÉ h·ªßy
  if (event.key === 'Escape') {
    event.preventDefault();
    const canvas = event.target.closest('.agentic-canvas');
    const cancelBtn = canvas.querySelector('.cancel-btn');
    cancelEdit(cancelBtn);
  }
}

function formatText(command) {
  document.execCommand(command, false, null);
}

// C·∫≠p nh·∫≠t function selectAllCanvas
function selectAllCanvas(button) {
  const canvas = button.closest('.agentic-canvas');
  const content = canvas.querySelector('.canvas-content');
  
  if (window.getSelection) {
    const selection = window.getSelection();
    const range = document.createRange();
    range.selectNodeContents(content);
    selection.removeAllRanges();
    selection.addRange(range);
  } else if (document.selection) {
    const range = document.body.createTextRange();
    range.moveToElementText(content);
    range.select();
  }
}
function showWarning(message) {
  const warningEl = document.getElementById('warning-message');
  const warningText = document.getElementById('warning-text');
  warningText.textContent = message;
  warningEl.classList.add('visible');
  
  // T·ª± ƒë·ªông ·∫©n sau 5 gi√¢y
  setTimeout(() => {
    hideWarning();
  }, 5000);
}

// H√†m ·∫©n c·∫£nh b√°o
function hideWarning() {
  const warningEl = document.getElementById('warning-message');
  warningEl.classList.remove('visible');
}

// H√†m ki·ªÉm tra xung ƒë·ªôt
function checkConflict() {
  const hasFiles = uploadedFiles.length > 0;
  const hasSearch = isSearchEnabled;
  
  if (hasFiles && hasSearch) {
    showWarning('‚ö†Ô∏è Kh√¥ng th·ªÉ s·ª≠ d·ª•ng ƒë·ªìng th·ªùi t√¨m ki·∫øm v√† upload file. Vui l√≤ng ch·ªçn m·ªôt ch·ª©c nƒÉng.');
    return true;
  }
  return false;
}
</script>
</body>
</html>
